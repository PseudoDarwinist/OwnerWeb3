This code does something similar to the first example, stores and updates a variable inside the smart contract. But in this case, instead of a simple integer we have a address data type.
This address (account identifier) represents an owner, that has some specific privilege over the contract, for example to call some function or to access some value.
Concepts
private: Just like in contract functions, attributes have access modifiers, these modifiers restrict from “where” the code can read or change the state of the attribute. In this case is private, which means that the variable only can be accessed from the contract functions. If you want to keep the variable as read-only, then you can declare it as private and then create a getter function with a view modifier that only returns the value.
event: is an inheritable member of a contract. An event is emitted, it stores the arguments passed in transaction logs. These logs are stored on the blockchain and are accessible using the address of the contract. In the example, we create an event emitted each time the owner is changed in the changeOwner function.
constructor & msg.sender: The constructor function is called when the smart contract is deployed, since the smart contract is immutable, it only can be deployed once, therefore the constructor function will be called just once as well. msg.sender is the address where the current (external) function call came from. In this case we initialize the owner variable with the address of the deployer.
modifier: Solidity provides this keyword to create your own modifiers with custom logic. If the first argument of require evaluates to false then the operations inside the functions are reverted, this is also useful to check that the functions are called correctly. As a second argument, you can also provide an explanation about what went wrong.
